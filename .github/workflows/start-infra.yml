name: Arrancar EC2 y RDS

on:
  schedule:
    # 07:00 VET = 11:00 UTC solo Lunes-Sábado (1-6). Domingo (0) no enciende.
    - cron: '0 11 * * 1-6'
  workflow_dispatch: {}

jobs:
  start:
    runs-on: ubuntu-latest
    env:
      AWS_REGION: ${{ secrets.AWS_REGION }}
      EC2_ID: i-01b29862c501519bd
      RDS_ID: arow-db

    steps:
    - name: Checkout repo
      uses: actions/checkout@v3

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id:     ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region:            ${{ env.AWS_REGION }}

    - name: Arrancar instancia EC2
      run: |
        set -euo pipefail
        aws ec2 start-instances --instance-ids $EC2_ID
        aws ec2 wait instance-running --instance-ids $EC2_ID

    - name: Esperar checks 2/2 de EC2
      run: |
        set -euo pipefail
        aws ec2 wait instance-status-ok --instance-ids $EC2_ID

    - name: Asegurar Docker y contenedores arriba (SSM)
      env:
        CONTAINER_NAMES: ${{ vars.CONTAINER_NAMES }}
      run: |
        set -euo pipefail
        DOC="AWS-RunShellScript"
        echo "Enviando comando SSM para iniciar Docker y contenedores..."
        CMD_ID=$(aws ssm send-command \
          --instance-ids "$EC2_ID" \
          --document-name "$DOC" \
          --comment "Arrancar Docker y contenedores" \
          --parameters commands='#!/bin/bash
        set -euo pipefail
        if ! command -v docker >/dev/null 2>&1; then
          echo "docker no instalado" >&2
          exit 1
        fi
        # Asegurar servicio docker arriba
        if command -v systemctl >/dev/null 2>&1; then
          sudo systemctl start docker || true
        fi
        sleep 2
        # Intentar levantar todos los contenedores existentes
        ids=$(docker ps -a -q)
        if [ -n "$ids" ]; then
          docker start $ids || true
        fi
        # Verificación opcional por nombres esperados
        if [ -n "'"'${CONTAINER_NAMES:-}'"'" ]; then
          missing=0
          for name in ${CONTAINER_NAMES}; do
            if ! docker ps --format "{{.Names}}" | grep -E "^${name}(\\$|:)" -q; then
              echo "Contenedor esperado no está arriba: $name" >&2
              missing=$((missing+1))
            fi
          done
          if [ "$missing" -gt 0 ]; then
            exit 2
          fi
        fi
        docker ps
        ' \
          --query 'Command.CommandId' --output text)

        echo "Esperando resultado de SSM Command $CMD_ID..."
        for i in {1..60}; do
          STATUS=$(aws ssm get-command-invocation --command-id "$CMD_ID" --instance-id "$EC2_ID" --query 'Status' --output text || true)
          echo "SSM status: $STATUS"
          if [ "$STATUS" = "Success" ]; then exit 0; fi
          if [ "$STATUS" = "Cancelled" ] || [ "$STATUS" = "Failed" ] || [ "$STATUS" = "TimedOut" ]; then
            aws ssm get-command-invocation --command-id "$CMD_ID" --instance-id "$EC2_ID" || true
            exit 1
          fi
          sleep 5
        done
        echo "Timeout esperando ejecución SSM"
        exit 1

    - name: Arrancar instancia RDS (al final)
      run: |
        set -euo pipefail
        aws rds start-db-instance --db-instance-identifier $RDS_ID
        aws rds wait db-instance-available --db-instance-identifier $RDS_ID

    - name: Healthchecks de EasyPanel y proyectos
      env:
        EASYPANEL_URL: ${{ vars.EASYPANEL_URL }}
        HEALTHCHECK_URLS: ${{ vars.HEALTHCHECK_URLS }}
      run: |
        set -euo pipefail
        urls=""
        if [ -n "${EASYPANEL_URL:-}" ]; then
          urls="$EASYPANEL_URL"
        fi
        if [ -n "${HEALTHCHECK_URLS:-}" ]; then
          urls="$urls"$'\n'"$HEALTHCHECK_URLS"
        fi

        echo "URLs a verificar:" || true
        echo "$urls" | sed '/^$/d' | nl -ba || true

        # Si no hay URLs configuradas, continuar sin fallar
        if [ -z "$(echo "$urls" | sed '/^$/d')" ]; then
          echo "No se configuraron URLs en vars.EASYPANEL_URL / vars.HEALTHCHECK_URLS; omitiendo healthchecks."
          exit 0
        fi

        ok_count=0
        total=$(echo "$urls" | sed '/^$/d' | wc -l | tr -d ' ')
        while IFS= read -r url; do
          [ -z "$url" ] && continue
          echo "Verificando $url"
          success=0
          for i in {1..30}; do
            code=$(curl -k -fsS -o /dev/null -w "%{http_code}" "$url" || true)
            if [ -n "$code" ] && [ "$code" -ge 200 ] && [ "$code" -lt 400 ]; then
              echo "OK $url (HTTP $code)"
              success=1
              break
            fi
            echo "Intento $i/30: HTTP ${code:-N/A}; reintentando en 10s..."
            sleep 10
          done
          if [ "$success" -eq 1 ]; then
            ok_count=$((ok_count+1))
          else
            echo "FALLO: $url no respondió 2xx/3xx tras los reintentos"
          fi
        done <<<"$(echo "$urls" | sed '/^$/d')"

        echo "Healthchecks OK: $ok_count / $total"
        [ "$ok_count" -eq "$total" ]
